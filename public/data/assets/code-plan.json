{
  "claim_generator": "LivingContent/1.0.0",
  "claim_generator_info": [{ "name": "Living Content", "version": "1.0.0" }],
  "title": "Planner",
  "format": "text/x-python",
  "instance_id": "urn:uuid:code-plan",
  "assertions": [
    {
      "label": "lco.code",
      "data": {
        "function": "plan",
        "module": "core.tools.knowledge.phases.planning",
        "hash": "sha256:2c4d6e8f0a1b3c5d7e9f1a2b4c6d8e0f2a4b6c8d"
      }
    }
  ],
  "source_code": "@chain_link(computation=\"plan\", input_asset_type=\"model\", output_asset_type=\"document\")\nasync def plan(\n    user_query: str,\n    reflection_context: ReflectionContext,\n    conversation_history: list[dict],\n    domain_context: str = \"\",\n    on_sql_building: callable = None,\n) -> tuple[ExecutionPlan, dict]:\n    \"\"\"Phase 2: Plan retrieval strategy based on reflection\n\n    Args:\n        user_query: Original user query text\n        reflection_context: Output from reflection phase\n        conversation_history: Recent conversation messages for context\n        domain_context: Domain context with collection statistics\n        on_sql_building: Optional async callback when SQL query generation starts\n\n    Returns:\n        Tuple of (ExecutionPlan, lineage_data_dict)\n    \"\"\"\n    benchmark = get_current_benchmark()\n\n    if benchmark:\n        benchmark.start_timer(\"phase_planning\")\n\n    # Get config for query limits\n    max_internal_queries = get_config(\n        \"tools.knowledge.limits.max_internal_queries\"\n    )\n    max_external_queries = get_config(\n        \"tools.knowledge.limits.max_external_queries\"\n    )\n\n    # Build gaps text\n    gaps_text = \"\\n\".join(\n        f\"- [{gap.gap_id}] {gap.description} (priority: {gap.priority})\"\n        for gap in reflection_context.gaps\n    )\n\n    # Get available columns and document types for SQL queries\n    available_columns = get_available_columns()\n    document_types = get_document_types()\n\n    # Format conversation history for context\n    history_text = format_conversation_history(conversation_history)\n\n    # Load and format system prompt\n    planning_prompt = get_prompt_content(\"tools.knowledge.planning\")\n    system_prompt = planning_prompt.format(\n        max_internal_queries=max_internal_queries,\n        max_external_queries=max_external_queries,\n        domain_context=domain_context if domain_context else \"Not available\",\n        conversation_history=history_text,\n        reflection_analysis=reflection_context.reasoning_summary,\n        identified_gaps=gaps_text,\n        available_columns=available_columns,\n    )\n\n    result, _ = await json_response(\n        system_prompt=system_prompt,\n        user_prompt=user_query,\n        response_schema=schema,\n        phase=\"planning\",\n    )\n\n    # Build search queries\n    search_queries = []\n    for pq in result[\"planned_queries\"]:\n        search_queries.append(\n            SearchQuery(\n                query_text=pq.get(\"query_text\", \"\"),\n                keywords=pq.get(\"keywords\", []),\n                needs_external_search=pq.get(\"needs_external_search\", False),\n                skip_internal_search=pq.get(\"skip_internal_search\", False),\n                use_visual_search=pq.get(\"use_visual_search\", False),\n                use_sql_query=pq.get(\"use_sql_query\", False),\n            )\n        )\n\n    execution_plan = ExecutionPlan(\n        plan_id=\"plan_0\",\n        addressing_gaps=[gap.gap_id for gap in reflection_context.gaps],\n        queries=search_queries,\n        estimated_chunks=len(search_queries) * 15,\n    )\n\n    return {\n        \"execution_plan\": {\n            \"plan_id\": execution_plan.plan_id,\n            \"addressing_gaps\": execution_plan.addressing_gaps,\n            \"estimated_chunks\": execution_plan.estimated_chunks,\n        },\n        \"queries\": [\n            {\n                \"text\": q.query_text,\n                \"keywords\": q.keywords,\n                \"needs_external_search\": q.needs_external_search,\n                \"skip_internal_search\": q.skip_internal_search,\n                \"use_visual_search\": q.use_visual_search,\n                \"use_sql_query\": q.use_sql_query,\n            }\n            for q in search_queries\n        ],\n    }",
  "signature_info": {
    "alg": "ES256",
    "issuer": "did:key:zQ3shwc61yUNaJZBX2L9mZd3xhWjTEqD52dA3JxBnZnu78E3d",
    "time": "2026-01-14T18:15:22Z"
  }
}
