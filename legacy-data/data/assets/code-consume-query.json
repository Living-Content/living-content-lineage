{
  "claim_generator": "LivingContent/1.0.0",
  "claim_generator_info": [{ "name": "Living Content", "version": "1.0.0" }],
  "title": "Query Consumer",
  "format": "application/vnd.livingcontent.code+python",
  "instance_id": "urn:uuid:code-consume-query",

  "assertions": [
    {
      "label": "c2pa.actions",
      "data": {
        "actions": [{
          "action": "c2pa.created",
          "digitalSourceType": "http://cv.iptc.org/newscodes/digitalsourcetype/algorithmicMedia",
          "softwareAgent": { "name": "Living Content Pipeline", "version": "1.0.0" },
          "when": "2026-01-14T18:15:18Z"
        }]
      }
    },
    {
      "label": "lco.code",
      "data": {
        "function": "_consume_query",
        "module": "core.tasks.query",
        "computation": "_consume_query",
        "decorator": "chain_start",
        "hash": "sha256:abc123def456abc123def456abc123def456abc123def456abc123def456abc1"
      }
    },
    {
      "label": "lco.execution",
      "data": {
        "execution_start_time": "1768414494.3466911",
        "execution_end_time": "1768414515.4117174",
        "execution_duration_ms": 21065.03,
        "previous_function": null,
        "next_function": "select_tool"
      }
    }
  ],

  "source_code": "@chain_start(calls=[\"select_tool\"], output_asset_type=\"document\")\nasync def _consume_query(\n    lineage_ctx: LineageContext,\n    request_id: str,\n    request_message_id: str,\n    query_request_json: str,\n    tool_id: str | None = None,\n) -> dict:\n    \"\"\"Consume query and execute tool chain with lineage tracking.\"\"\"\n    logger.info(f\"=== TASK ENTRY: process_query {request_id} ===\")\n\n    deps = await dependencies.get()\n    request_state = RequestStateManager(deps.redis_client)\n\n    logger.info(f\"Processing query {request_id} for user {lineage_ctx.user_id}\")\n\n    try:\n        query_data = json.loads(query_request_json)\n        user_query = QueryRequest(**query_data)\n\n        await request_state.set_pending(request_id, lineage_ctx.user_id)\n        await request_state.add_active_request(lineage_ctx.user_id, request_id)\n\n        gaim_id = get_env(\"GAIM_ID\")\n        await initialize_lineage_state(\n            lineage_id=lineage_ctx.lineage_id,\n            gaim_id=gaim_id,\n            content_session_id=lineage_ctx.content_session_id,\n            user_id=lineage_ctx.user_id,\n            redis_client=deps.redis_client,\n            response_message_id=lineage_ctx.response_message_id,\n        )\n\n        tool_ctx = ToolContext(\n            connection_manager=deps.connection_manager,\n            request_message_id=request_message_id,\n        )\n\n        execution_start = time.perf_counter()\n\n        if not tool_id:\n            query_text = user_query.messages[-1].content if user_query.messages else \"\"\n            result = await deps.tool_registry.select_tool(\n                lineage_ctx, tool_ctx, query_text,\n                {\"required\": user_query.plugin_data or {}, \"additional\": user_query.additional_data}\n            )\n            tool_id = result.tool_id or \"knowledge_query\"\n\n        selected_tool_wrapper, *_ = deps.tool_registry.get_callable(tool_id)\n        tool_response = selected_tool_wrapper(user_query, lineage_ctx, tool_ctx)\n\n        if inspect.isasyncgen(tool_response):\n            full_response = await _stream_response(\n                deps, tool_response, lineage_ctx.user_id, request_id, request_state\n            )\n        else:\n            result = await tool_response\n            await request_state.set_complete(request_id)\n            full_response = str(result)\n\n        user_content = user_query.messages[-1].content if user_query.messages else \"\"\n        await _save_messages(\n            deps, lineage_ctx.user_id, lineage_ctx.content_session_id,\n            request_message_id, lineage_ctx.response_message_id,\n            user_content, full_response\n        )\n\n        execution_time = (time.perf_counter() - execution_start) * 1000\n        logger.info(f\"Query {request_id} completed in {execution_time:.0f}ms\")\n\n        await request_state.remove_active_request(lineage_ctx.user_id, request_id)\n\n        return {\n            \"query\": user_content,\n            \"message_count\": len(user_query.messages),\n            \"has_plugin_data\": bool(user_query.plugin_data),\n        }\n\n    except TaskCancelledError:\n        raise\n    except Exception as e:\n        logger.error(f\"Query {request_id} failed: {e}\")\n        await _notify_error(deps, request_state, request_id, lineage_ctx.user_id, str(e))\n        raise",

  "claim": {
    "type": "certificate",
    "provider": "LCO",
    "alg": "ES256",
    "issuer": "did:key:zQ3shwc61yUNaJZBX2L9mZd3xhWjTEqD52dA3JxBnZnu78E3d",
    "time": "2026-01-14T18:15:18Z"
  }
}
